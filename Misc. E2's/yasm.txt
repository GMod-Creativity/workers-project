@name CPU
@inputs Port1 Port2 Port3 Port4 Port5 Port6 Port7 Port8
@outputs Port1 Port2 Port3 Port4 Port5 Port6 Port7 Port8
@outputs [CodeString TempString]:string [CodeArray Errors]:array I1
@outputs Op P1 P2 Done C [Mem Labels]:array E Output:string Ticks
@outputs Comp:vector2 S [Strings Stack PStack]:array
if(first()){    #Preprocessing
    E = 1
    I1 = 1
    C = 1
    S = 1
    CodeString = "  0001:
                    001F00FF;
                    001F3D33;
                    0020;
                    00210001;
                    001E0001;
                    "
    CodeString = CodeString:replace("\n", "")
    CodeString = CodeString:replace(" ", "")
    for(I = 0, CodeString:length()){
        if(CodeString[I] == ";"){
            CodeArray[I1, string] = TempString
            TempString = ""
            I1++
        }
        elseif(CodeString[I] == ":"){
            CodeArray[I1, string] = TempString + ":"
            TempString = ""
            I1++
        }
        else{
            TempString += CodeString[I]
        }
    }
    I1 = 0
    for(I = 0, CodeArray:count()){
        if(CodeArray[I, string]:right(1) == ":"){
            I1++
            Labels[I1, vector2] = vec2(I, CodeArray[I, string]:left(4):toNumber(16))
        }
    }
    timer("a", 1)
}
if(clk("a") & !Done){   #Opcodes
    while(perf() & !Done){
        Done = C > CodeArray:count()
        Op = CodeArray[C, string]:left(4):toNumber(16)
        P1 = CodeArray[C, string]:sub(5, 8):toNumber(16)
        P2 = CodeArray[C, string]:sub(9, 12):toNumber(16)
        if(Op == 0x00){             #End Program
            Done = 1
            break
        }
        elseif(Op == 0x01){         #Mov param2 to memory cell param1
            Mem[P1, number] = P2
        }
        elseif(Op == 0x02){
            Mem[P1, number] = Mem[P2, number]
        }
        elseif(Op == 0x03){
            Mem[P1, number] = Mem[P1, number] + Mem[P2, number]
        }
        elseif(Op == 0x04){
            Mem[P1, number] = Mem[P1, number] - Mem[P2, number]
        }
        elseif(Op == 0x05){
            Mem[P1, number] = Mem[P1, number] * Mem[P2, number]
        }
        elseif(Op == 0x06){
            Mem[P1, number] = Mem[P1, number] / Mem[P2, number]
        }
        elseif(Op == 0x07){
            Mem[P1, number] = Mem[P1, number] + P2
        }
        elseif(Op == 0x08){
            Mem[P1, number] = Mem[P1, number] - P2
        }
        elseif(Op == 0x09){
            Mem[P1, number] = Mem[P1, number] * P2
        }
        elseif(Op == 0x0A){
            if(P2 != 0){
                Mem[P1, number] = Mem[P1, number] / P2
            }
            else{
                Errors[E, number] = 1 
                E++
                Done = 1
                break
            }
        }
        elseif(Op == 0x0B){
            Mem[P1, number] = Mem[P1, number] + 1
        }
        elseif(Op == 0x0C){
            Mem[P1, number] = Mem[P1, number] - 1
        }
        elseif(Op == 0x0D){
            I = 0
            while(Mem[P1 + I, number] != P2){
                Output += toChar(Mem[P1 + I, number])
                I++
                if(I > Mem:count()){
                    Errors[E, number] = 2
                    E++
                    Done = 1
                    break
                }
            }
        }
        elseif(Op == 0x0E){
            Output += toChar(P2)
        }
        elseif(Op == 0x10){
            I = 0
            while(Labels[I, vector2]:y() != P1){
                I++
                if(I > Labels:count()){
                    Errors[E, number] = 3
                    E++
                    Done = 1
                    break
                }
            }
            C = Labels[I, vector2]:x()
        }
        elseif(Op == 0x11){
            Comp = vec2(P1, P2)
        }
        elseif(Op == 0x12 & Mem[Comp:x(), number] == Comp:y()){
            I = 0
            while(Labels[I, vector2]:y() != P1){
                I++
                if(I > Labels:count()){
                    Errors[E, number] = 3
                    E++
                    Done = 1
                    break
                }
            }
            C = Labels[I, vector2]:x()
        }
        elseif(Op == 0x13 & Mem[Comp:x(), number] != Comp:y()){
            I = 0
            while(Labels[I, vector2]:y() != P1){
                I++
                if(I > Labels:count()){
                    Errors[E, number] = 3
                    E++   
                    Done = 1
                    break
                }
            }
            C = Labels[I, vector2]:x()
        }
        elseif(Op == 0x14){
            Mem[Mem[P1, number], number] = P2
        }
        elseif(Op == 0x15){
            Mem[Mem[P1, number], number] = Mem[P2, number]
        }
        elseif(Op == 0x16){
            Strings[S, vector2] = vec2(P1, P2)
            S++
        }
        elseif(Op == 0x17){
            I = 0
            while(Strings[I, vector2]:x() != P1){
                I++
            }
            I = Strings[I, vector2]:x()
            while(Mem[I, number] != 0){
                I++
            }
            Mem[I, number] = P2
        }
        elseif(Op == 0x18){
            I = 0
            while(Strings[I, vector2]:x() != P1){
                I++
            }
            I = Strings[I, vector2]:x()
            while(Mem[I, number] != 0){
                Output += toChar(Mem[I, number])
                I++
            }
        }
        elseif(Op == 0x19){
            Stack:pushNumber(C)   
            I = 0
            while(Labels[I, vector2]:y() != P1){
                I++
                if(I > Labels:count()){
                    Errors[E, number] = 3
                    E++
                    Done = 1
                    break
                }
            }
            C = Labels[I, vector2]:x()
        }
        elseif(Op == 0x1A){
            C = Stack[Stack:count(), number]
            Stack:popNumber()
        }
        elseif(Op == 0x1B){
            Mem[P1, number] = ioGetInputNumber("Port" + P2)
        }
        elseif(Op == 0x1C){
            ioSetOutput("Port" + P1, Mem[P2, number])
        }
        elseif(Op == 0x1D){
            ioSetOutput("Port" + P1, P2)
        }
        elseif(Op == 0x1E){
            PStack:pushNumber(Mem[P1, number])
        }
        elseif(Op == 0x1F){
            PStack:pushNumber(P1)
        }
        elseif(Op == 0x20){
            PStack:popNumber()
        }
        elseif(Op == 0x21){
            Mem[P1, number] = PStack:popNumber()
        }
        C++
    }
    Ticks++
    timer("a", 1)
}