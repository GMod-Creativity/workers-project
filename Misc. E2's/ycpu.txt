@name yCPU
@inputs Port1 Port2 Port3 Port4 Port5 Port6 Port7 Port8
@outputs Port1 Port2 Port3 Port4 Port5 Port6 Port7 Port8
@outputs LOL [CodeString TempString]:string [CodeArray Errors]:array I1
@outputs Op P1 P2 Done C [Mem Labels]:array E Output:string Ticks
@outputs Comp:vector2 S [Strings Stack PStack]:array Halt I2 I3 Done1
@outputs Done2
###################################################
#   __     __   _______    _______    __    __    #
#   \ \   / /  |   ____|  |   _   |  |  |  |  |   #
#    \ \_/ /   |  |       |  |_|  |  |  |  |  |   #
#     \   /    |  |       |   ____|  |  |  |  |   #
#      \ /     |  |       |  |       |  |  |  |   #
#      | |     |  |____   |  |       |  |__|  |   #
#      |_|     |_______|  |__|       |________|   #
#                                                 #
###################################################
if(first()){
    E = 1
    I1 = 1
    C = 1
    S = 1 
    CodeString = "
                    0001:
                    000B0001;
                    00100001;
                 "
    CodeString = CodeString:replace("\n", "")
    CodeString = CodeString:replace(" ", "")
}
if(first() | clk("b")){    #Preprocessing
    while(!Done1 & perf()){
        I2++
        if(CodeString[I2] == ";"){
            CodeArray[I1, string] = TempString
            TempString = ""
            I1++
        }
        elseif(CodeString[I2] == ":"){
            CodeArray[I1, string] = TempString + ":"
            TempString = ""
            I1++
        }
        else{
            TempString += CodeString[I2]
        }
    }
    if(I2 >= CodeString:length()){
        Done1 = 1
    }
    if(Done1 & !Done2){
    Done2 = 1
    I1 = 0
    }
    if(Done1 == 1){
        while(I3 < CodeArray:count() & perf()){
            I3++
            if(CodeArray[I3, string]:right(1) == ":"){
                Labels[CodeArray[I3, string]:left(4):toNumber(16), number] = I3
            }
        }
    }
    if(!Done1 | I3 < CodeArray:count()){
        timer("b", 1)
    }
    else{
        timer("a", 1)
    }
}
if(clk("a") & !Done){   #Opcodes
    while(perf() & !Done){
        if(CodeArray[C, string][CodeArray[C, string]:length()] != ":"){
            Done = C > CodeArray:count()
            Op = CodeArray[C, string]:left(4):toNumber(16) 
            P1 = CodeArray[C, string]:sub(5, 8):toNumber(16)
            P2 = CodeArray[C, string]:sub(9, 12):toNumber(16)
            if(Op == 0x00){             #End Program
                Done = 1
                break
            }
            elseif(Op == 0x01){         #Mov param2 to memory cell param1
                Mem[P1, number] = P2
            }
            elseif(Op == 0x02){
                Mem[P1, number] = Mem[P2, number]
            }
            elseif(Op == 0x03){
                Mem[P1, number] = Mem[P1, number] + Mem[P2, number]
            }
            elseif(Op == 0x04){
                Mem[P1, number] = Mem[P1, number] - Mem[P2, number]
            }
            elseif(Op == 0x05){
                Mem[P1, number] = Mem[P1, number] * Mem[P2, number]
            }
            elseif(Op == 0x06){
                Mem[P1, number] = Mem[P1, number] / Mem[P2, number]
            }
            elseif(Op == 0x07){
                Mem[P1, number] = Mem[P1, number] + P2
            }
            elseif(Op == 0x08){
                Mem[P1, number] = Mem[P1, number] - P2
            }
            elseif(Op == 0x09){
                Mem[P1, number] = Mem[P1, number] * P2
            }
            elseif(Op == 0x0A){
                if(P2 != 0){
                    Mem[P1, number] = Mem[P1, number] / P2
                }
                else{
                    Errors[E, number] = 1 
                    E++
                    Done = 1
                    break
                }
            }
            elseif(Op == 0x0B){
                Mem[P1, number] = Mem[P1, number] + 1
            }
            elseif(Op == 0x0C){
                Mem[P1, number] = Mem[P1, number] - 1
            }
            elseif(Op == 0x0D){
                I = 0
                while(Mem[P1 + I, number] != P2){
                    Output += toChar(Mem[P1 + I, number])
                    I++
                    if(I > Mem:count()){
                        Errors[E, number] = 2
                        E++
                        Done = 1
                        break
                    }
                }
            }
            elseif(Op == 0x0E){
                Output += toChar(P2)
            }
            elseif(Op == 0x10){
                if(Labels[P1, number] != 0){
                    C = Labels[P1, number]
                }
            }
            elseif(Op == 0x11){
                Comp = vec2(P1, P2)
            }
            elseif(Op == 0x12 & Mem[Comp:x(), number] == Comp:y()){
                if(Labels[P1, number] != 0){
                    C = Labels[P1, number]
                }
            }
            elseif(Op == 0x13 & Mem[Comp:x(), number] != Comp:y()){
                if(Labels[P1, number] != 0){
                    C = Labels[P1, number]
                }
            }
            elseif(Op == 0x14){
                Mem[Mem[P1, number], number] = P2
            }
            elseif(Op == 0x15){
                Mem[Mem[P1, number], number] = Mem[P2, number]
            }
            elseif(Op == 0x16){
                Strings[S, vector2] = vec2(P1, P2)
                S++
            }
            elseif(Op == 0x17){
                I = 0
                while(Strings[I, vector2]:x() != P1){
                    I++
                }
                I = Strings[I, vector2]:x()
                while(Mem[I, number] != 0){
                    I++
                }
                Mem[I, number] = P2
            }
            elseif(Op == 0x18){
                I = 0
                while(Strings[I, vector2]:x() != P1){
                    I++
                }
                I = Strings[I, vector2]:x()
                while(Mem[I, number] != 0){
                    Output += toChar(Mem[I, number])
                    I++
                }
            }
            elseif(Op == 0x19){
                Stack:pushNumber(C)   
                I = 0
                while(Labels[I, vector2]:y() != P1){
                    I++
                    if(I > Labels:count()){
                        Errors[E, number] = 3
                        E++
                        Done = 1
                        break
                    }
                }
                C = Labels[I, vector2]:x()
            }
            elseif(Op == 0x1A){
                C = Stack[Stack:count(), number]
                Stack:popNumber()
            }
            elseif(Op == 0x1B){
                Mem[P1, number] = ioGetInputNumber("Port" + P2)
            }
            elseif(Op == 0x1C){
                ioSetOutput("Port" + P1, Mem[P2, number])
            }
            elseif(Op == 0x1D){
                ioSetOutput("Port" + P1, P2)
            }
            elseif(Op == 0x1E){
                PStack:pushNumber(Mem[P1, number])
            }
            elseif(Op == 0x1F){
                PStack:pushNumber(P1)
            }
            elseif(Op == 0x20){
                PStack:popNumber()
            }
            elseif(Op == 0x21){
                Mem[P1, number] = PStack:popNumber()
            }
            elseif(Op == 0x22){
                Halt = P1
            }
            elseif(Op == 0x23){
                Mem[P1, number] = sin(Mem[P2, number])
            }
            elseif(Op == 0x24){
                Mem[P1, number] = sin(P2)
            }
            elseif(Op == 0x25){
                Mem[P1, number] = cos(Mem[P2, number])
            }
            elseif(Op == 0x26){
                Mem[P1, number] = cos(P2)
            }
            elseif(Op == 0x27){
                Mem[P1, number] = abs(Mem[P2, number])
            }
            elseif(Op == 0x28){
                C++
                break
            }
            elseif(Op == 0x29){
                PMem = CodeArray
            }
            C++
            if(Halt){
                break
            }
        }
        else{
            C++
        }
    }
    Ticks++
    timer("a", 1)
}